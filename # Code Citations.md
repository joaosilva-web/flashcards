# Code Citations

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
```

## License: MIT

https://github.com/vercel/next.js/blob/42f8ac16c6ff497f297198e42fc2abb113bf4a7b/examples/with-supabase/utils/supabase/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request
```

## License: unknown

https://github.com/iutomwen/fashionandfabric/blob/777b466b47d5446ea0fcee386b18b15146a2c7e7/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request
```

## License: MIT

https://github.com/Murad-Git/yummy/blob/07207cf32fe51e2129e221b006175a51510d802e/app/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request
```

## License: unknown

https://github.com/W5DEV/next-recipes/blob/e8334c8a56ebcf43186e7a1296881ebe70958fd5/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request
```

## License: unknown

https://github.com/JrFelix540/digi-forum/blob/64f50f0823a22321d4bf74bc6524d3f8eaa31a4f/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any
```

## License: unknown

https://github.com/JrFelix540/digi-forum/blob/64f50f0823a22321d4bf74bc6524d3f8eaa31a4f/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any
```

## License: unknown

https://github.com/JrFelix540/digi-forum/blob/64f50f0823a22321d4bf74bc6524d3f8eaa31a4f/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any
```

## License: unknown

https://github.com/JrFelix540/digi-forum/blob/64f50f0823a22321d4bf74bc6524d3f8eaa31a4f/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any
```

## License: unknown

https://github.com/JrFelix540/digi-forum/blob/64f50f0823a22321d4bf74bc6524d3f8eaa31a4f/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any
```

## License: unknown

https://github.com/JrFelix540/digi-forum/blob/64f50f0823a22321d4bf74bc6524d3f8eaa31a4f/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any
```

## License: unknown

https://github.com/JrFelix540/digi-forum/blob/64f50f0823a22321d4bf74bc6524d3f8eaa31a4f/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}

// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any
```

## License: unknown

https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```
Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```

flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ ‚îú‚îÄ‚îÄ (auth)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ login/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ signup/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx
‚îÇ ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Layout com navega√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Dashboard principal
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ decks/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Listagem de baralhos
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Detalhes do deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar deck
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Modo de estudo
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cards/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ [id]/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ edit/
‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Editar card
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ new/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Criar novo card
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Importar CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page.tsx # Estat√≠sticas
‚îÇ ‚îú‚îÄ‚îÄ api/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Upload e parsing de CSV
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ webhook/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ route.ts # Webhooks do Supabase
‚îÇ ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ ‚îú‚îÄ‚îÄ ui/ # Componentes shadcn/ui
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ button.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ input.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ select.tsx
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ...
‚îÇ ‚îú‚îÄ‚îÄ flashcard/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-display.tsx # Componente do card com flip
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-form.tsx # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ difficulty-buttons.tsx # Bot√µes de dificuldade
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formatted-text.tsx # Renderiza texto formatado
‚îÇ ‚îú‚îÄ‚îÄ deck/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-card.tsx # Card de preview do deck
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-list.tsx # Lista de decks
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ deck-stats.tsx # Estat√≠sticas do deck
‚îÇ ‚îú‚îÄ‚îÄ study/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-session.tsx # Sess√£o de estudo
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ progress-bar.tsx # Barra de progresso
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ review-summary.tsx # Resumo da sess√£o
‚îÇ ‚îú‚îÄ‚îÄ import/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-uploader.tsx # Componente de upload
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ import-preview.tsx # Preview antes de importar
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ format-guide.tsx # Guia de formata√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ stats/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ charts.tsx # Gr√°ficos de estat√≠sticas
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ streak-counter.tsx # Contador de sequ√™ncia
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ daily-goal.tsx # Meta di√°ria
‚îÇ ‚îî‚îÄ‚îÄ layout/
‚îÇ ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ ‚îú‚îÄ‚îÄ supabase/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ client.ts # Cliente do Supabase (client-side)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ server.ts # Cliente do Supabase (server-side)
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ middleware.ts # Middleware de autentica√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ actions/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ deck-actions.ts # Server Actions para decks
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ card-actions.ts # Server Actions para cards
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ study-actions.ts # Server Actions para estudo
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ import-actions.ts # Server Actions para importa√ß√£o
‚îÇ ‚îú‚îÄ‚îÄ algorithm/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sm2.ts # Implementa√ß√£o do SM-2
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ scheduler.ts # Agendador de revis√µes
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ types.ts # Tipos do algoritmo
‚îÇ ‚îú‚îÄ‚îÄ parsers/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ csv-parser.ts # Parser de CSV
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ markdown-parser.ts # Converter marca√ß√µes em HTML
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitizer.ts # Sanitiza√ß√£o contra XSS
‚îÇ ‚îú‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ date.ts # Utilit√°rios de data
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stats.ts # C√°lculos de estat√≠sticas
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.ts # Valida√ß√£o de dados
‚îÇ ‚îî‚îÄ‚îÄ hooks/
‚îÇ ‚îú‚îÄ‚îÄ use-study-session.ts # Hook para sess√£o de estudo
‚îÇ ‚îú‚îÄ‚îÄ use-deck.ts # Hook para gerenciar deck
‚îÇ ‚îî‚îÄ‚îÄ use-stats.ts # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ ‚îú‚îÄ‚îÄ database.ts # Tipos gerados do Supabase
‚îÇ ‚îú‚îÄ‚îÄ flashcard.ts # Tipos de flashcard
‚îÇ ‚îî‚îÄ‚îÄ study.ts # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json

````

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
````

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/darianrosebrook/portfolio/blob/b6a4b450752fd065986efd4d35ce6e6cd6d24abb/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```


## License: unknown
https://github.com/Bartek532/syncreads/blob/baf57238ae99299758da21e2eac47f976a1ceb3d/apps/web/src/middleware.ts

```

Excelente! Analisei o CSV e vejo que usa nota√ß√£o matem√°tica LaTeX (delimitada por `$`). Vou criar uma arquitetura completa e detalhada para seu sistema de flashcards.

# üèóÔ∏è ARQUITETURA T√âCNICA COMPLETA

## 1. üìÅ ESTRUTURA DE PASTAS (Next.js App Router)

```
flashcard-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                 # Layout com navega√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                   # Dashboard principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Listagem de baralhos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Detalhes do deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       # Editar deck
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Modo de estudo
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx       # Editar card
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx           # Criar novo card
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx               # Importar CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx               # Estat√≠sticas
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts               # Upload e parsing de CSV
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts               # Webhooks do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes shadcn/ui
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ select.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ toast.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-display.tsx           # Componente do card com flip
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-form.tsx              # Formul√°rio de cria√ß√£o/edi√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ difficulty-buttons.tsx     # Bot√µes de dificuldade
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatted-text.tsx         # Renderiza texto formatado
‚îÇ   ‚îú‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-card.tsx              # Card de preview do deck
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-list.tsx              # Lista de decks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck-stats.tsx             # Estat√≠sticas do deck
‚îÇ   ‚îú‚îÄ‚îÄ study/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-session.tsx          # Sess√£o de estudo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress-bar.tsx           # Barra de progresso
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review-summary.tsx         # Resumo da sess√£o
‚îÇ   ‚îú‚îÄ‚îÄ import/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-uploader.tsx           # Componente de upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import-preview.tsx         # Preview antes de importar
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format-guide.tsx           # Guia de formata√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ stats/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts.tsx                 # Gr√°ficos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-counter.tsx         # Contador de sequ√™ncia
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ daily-goal.tsx             # Meta di√°ria
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ       ‚îú‚îÄ‚îÄ navbar.tsx
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ theme-toggle.tsx
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                  # Cliente do Supabase (client-side)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts                  # Cliente do Supabase (server-side)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts            # Server Actions para decks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card-actions.ts            # Server Actions para cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ study-actions.ts           # Server Actions para estudo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ import-actions.ts          # Server Actions para importa√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ algorithm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sm2.ts                     # Implementa√ß√£o do SM-2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts               # Agendador de revis√µes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Tipos do algoritmo
‚îÇ   ‚îú‚îÄ‚îÄ parsers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts              # Parser de CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ markdown-parser.ts         # Converter marca√ß√µes em HTML
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sanitizer.ts               # Sanitiza√ß√£o contra XSS
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date.ts                    # Utilit√°rios de data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.ts                   # C√°lculos de estat√≠sticas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts              # Valida√ß√£o de dados
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ use-study-session.ts       # Hook para sess√£o de estudo
‚îÇ       ‚îú‚îÄ‚îÄ use-deck.ts                # Hook para gerenciar deck
‚îÇ       ‚îî‚îÄ‚îÄ use-stats.ts               # Hook para estat√≠sticas
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ database.ts                    # Tipos gerados do Supabase
‚îÇ   ‚îú‚îÄ‚îÄ flashcard.ts                   # Tipos de flashcard
‚îÇ   ‚îî‚îÄ‚îÄ study.ts                       # Tipos de sess√£o de estudo
‚îú‚îÄ‚îÄ middleware.ts                      # Middleware do Next.js
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

---

## 2. üóÑÔ∏è MODELAGEM DE DADOS (Schema SQL)

```sql
-- ============================================
-- EXTENS√ïES
-- ============================================
create extension if not exists "uuid-ossp";

-- ============================================
-- TABELAS DE AUTENTICA√á√ÉO (Supabase Auth)
-- ============================================
-- As tabelas auth.users, auth.sessions j√° existem
-- Vamos criar uma tabela de perfil estendida

-- ============================================
-- TABELA: profiles
-- ============================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  daily_goal integer default 20,
  timezone text default 'UTC',
  theme text default 'system',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- ============================================
-- TABELA: decks (Baralhos)
-- ============================================
create table decks (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  name text not null,
  description text,
  color text default '#3b82f6',
  icon text default 'üìö',
  is_archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint name_not_empty check (char_length(name) > 0)
);

create index idx_decks_user_id on decks(user_id);
create index idx_decks_archived on decks(is_archived) where is_archived = false;

-- ============================================
-- TABELA: cards (Flashcards)
-- ============================================
create table cards (
  id uuid default uuid_generate_v4() primary key,
  deck_id uuid references decks(id) on delete cascade not null,
  front text not null,
  back text not null,
  front_html text,                    -- HTML renderizado (com formata√ß√£o)
  back_html text,                     -- HTML renderizado (com formata√ß√£o)
  tags text[] default array[]::text[], -- Tags para organiza√ß√£o
  position integer,                    -- Ordem no deck
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint front_not_empty check (char_length(front) > 0),
  constraint back_not_empty check (char_length(back) > 0)
);

create index idx_cards_deck_id on cards(deck_id);
create index idx_cards_tags on cards using gin(tags);

-- ============================================
-- TABELA: card_states (Estado de revis√£o)
-- ============================================
-- Esta tabela implementa o algoritmo de repeti√ß√£o espa√ßada
create table card_states (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null unique,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Campos do algoritmo SM-2
  ease_factor real default 2.5,           -- Fator de facilidade (EF)
  interval_days integer default 0,        -- Intervalo atual em dias
  repetitions integer default 0,          -- N√∫mero de repeti√ß√µes consecutivas corretas

  -- Estado atual
  state text default 'new',                -- 'new', 'learning', 'review', 'relearning'
  due_date timestamptz default now(),      -- Pr√≥xima data de revis√£o
  last_review_date timestamptz,            -- Data da √∫ltima revis√£o

  -- Estat√≠sticas
  total_reviews integer default 0,
  correct_reviews integer default 0,

  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint state_valid check (state in ('new', 'learning', 'review', 'relearning')),
  constraint ease_factor_range check (ease_factor >= 1.3),
  constraint interval_positive check (interval_days >= 0)
);

create index idx_card_states_card_id on card_states(card_id);
create index idx_card_states_user_id on card_states(user_id);
create index idx_card_states_due_date on card_states(due_date);
create index idx_card_states_state on card_states(state);

-- √çndice composto para buscar cards devido para um usu√°rio
create index idx_card_states_user_due on card_states(user_id, due_date)
  where due_date <= now();

-- ============================================
-- TABELA: review_logs (Hist√≥rico de revis√µes)
-- ============================================
create table review_logs (
  id uuid default uuid_generate_v4() primary key,
  card_id uuid references cards(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,

  -- Resposta do usu√°rio
  rating integer not null,                 -- 1=Again, 2=Hard, 3=Good, 4=Easy
  time_spent_ms integer,                   -- Tempo gasto na revis√£o

  -- Estado antes da revis√£o (para an√°lise)
  previous_ease_factor real,
  previous_interval_days integer,
  previous_state text,

  -- Estado depois da revis√£o
  new_ease_factor real,
  new_interval_days integer,
  new_state text,
  new_due_date timestamptz,

  reviewed_at timestamptz default now(),

  constraint rating_valid check (rating between 1 and 4)
);

create index idx_review_logs_card_id on review_logs(card_id);
create index idx_review_logs_user_id on review_logs(user_id);
create index idx_review_logs_reviewed_at on review_logs(reviewed_at);

-- ============================================
-- TABELA: study_sessions (Sess√µes de estudo)
-- ============================================
create table study_sessions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  deck_id uuid references decks(id) on delete set null,

  started_at timestamptz default now(),
  ended_at timestamptz,

  cards_studied integer default 0,
  cards_correct integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now()
);

create index idx_study_sessions_user_id on study_sessions(user_id);
create index idx_study_sessions_started_at on study_sessions(started_at);

-- ============================================
-- TABELA: daily_stats (Estat√≠sticas di√°rias)
-- ============================================
create table daily_stats (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  date date not null,

  cards_studied integer default 0,
  cards_correct integer default 0,
  new_cards integer default 0,
  review_cards integer default 0,
  total_time_ms integer default 0,

  created_at timestamptz default now(),

  unique(user_id, date)
);

create index idx_daily_stats_user_date on daily_stats(user_id, date);

-- ============================================
-- FUN√á√ïES E TRIGGERS
-- ============================================

-- Fun√ß√£o para atualizar o updated_at
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Triggers para updated_at
create trigger update_profiles_updated_at before update on profiles
  for each row execute function update_updated_at_column();

create trigger update_decks_updated_at before update on decks
  for each row execute function update_updated_at_column();

create trigger update_cards_updated_at before update on cards
  for each row execute function update_updated_at_column();

create trigger update_card_states_updated_at before update on card_states
  for each row execute function update_updated_at_column();

-- Fun√ß√£o para criar card_state automaticamente ao criar um card
create or replace function create_card_state_for_new_card()
returns trigger as $$
begin
  insert into card_states (card_id, user_id)
  select new.id, d.user_id
  from decks d
  where d.id = new.deck_id;

  return new;
end;
$$ language plpgsql;

create trigger create_card_state_trigger after insert on cards
  for each row execute function create_card_state_for_new_card();

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- Habilitar RLS em todas as tabelas
alter table profiles enable row level security;
alter table decks enable row level security;
alter table cards enable row level security;
alter table card_states enable row level security;
alter table review_logs enable row level security;
alter table study_sessions enable row level security;
alter table daily_stats enable row level security;

-- Policies para profiles
create policy "Users can view their own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on profiles for update
  using (auth.uid() = id);

-- Policies para decks
create policy "Users can view their own decks"
  on decks for select
  using (auth.uid() = user_id);

create policy "Users can create their own decks"
  on decks for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own decks"
  on decks for update
  using (auth.uid() = user_id);

create policy "Users can delete their own decks"
  on decks for delete
  using (auth.uid() = user_id);

-- Policies para cards
create policy "Users can view cards from their decks"
  on cards for select
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can create cards in their decks"
  on cards for insert
  with check (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can update cards in their decks"
  on cards for update
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

create policy "Users can delete cards from their decks"
  on cards for delete
  using (
    exists (
      select 1 from decks
      where decks.id = cards.deck_id
      and decks.user_id = auth.uid()
    )
  );

-- Policies para card_states
create policy "Users can view their own card states"
  on card_states for select
  using (auth.uid() = user_id);

create policy "Users can update their own card states"
  on card_states for update
  using (auth.uid() = user_id);

-- Policies para review_logs
create policy "Users can view their own review logs"
  on review_logs for select
  using (auth.uid() = user_id);

create policy "Users can create their own review logs"
  on review_logs for insert
  with check (auth.uid() = user_id);

-- Policies para study_sessions
create policy "Users can view their own study sessions"
  on study_sessions for select
  using (auth.uid() = user_id);

create policy "Users can create their own study sessions"
  on study_sessions for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own study sessions"
  on study_sessions for update
  using (auth.uid() = user_id);

-- Policies para daily_stats
create policy "Users can view their own daily stats"
  on daily_stats for select
  using (auth.uid() = user_id);

create policy "Users can insert their own daily stats"
  on daily_stats for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own daily stats"
  on daily_stats for update
  using (auth.uid() = user_id);
```

---

## 3. üßÆ ALGORITMO DE REPETI√á√ÉO ESPA√áADA (SM-2 Otimizado)

### **Modelagem Matem√°tica**

O algoritmo SM-2 (SuperMemo 2) calcula o intervalo de revis√£o baseado em:

1. **Ease Factor (EF)**: Fator de facilidade do cart√£o (inicia em 2.5)
2. **Intervalo**: Dias at√© pr√≥xima revis√£o
3. **Repeti√ß√µes**: N√∫mero de vezes consecutivas que acertou

#### **F√≥rmula do Ease Factor:**

$$EF' = EF + (0.1 - (5 - q) \times (0.08 + (5 - q) \times 0.02))$$

Onde:

- $q$ = qualidade da resposta (1 a 4)
- $EF'$ = novo ease factor
- $EF_{min} = 1.3$ (m√≠nimo permitido)

#### **F√≥rmula do Intervalo:**

```
Se q < 3 (resposta incorreta):
  - repetitions = 0
  - interval = 1 dia
  - estado = 'relearning'

Se q >= 3 (resposta correta):
  Se repetitions = 0:
    interval = 1 dia
  Se repetitions = 1:
    interval = 6 dias
  Se repetitions >= 2:
    interval = interval_anterior √ó EF
```

### **Implementa√ß√£o (TypeScript)**

```typescript
// lib/algorithm/types.ts
export type CardState = "new" | "learning" | "review" | "relearning";

export type DifficultyRating = 1 | 2 | 3 | 4; // 1=Again, 2=Hard, 3=Good, 4=Easy

export interface ReviewResult {
  newEaseFactor: number;
  newInterval: number;
  newRepetitions: number;
  newState: CardState;
  dueDate: Date;
}

export interface CardReviewData {
  easeFactor: number;
  interval: number;
  repetitions: number;
  state: CardState;
}

// lib/algorithm/sm2.ts
const MIN_EASE_FACTOR = 1.3;
const MAX_EASE_FACTOR = 2.5;

export function calculateNextReview(
  currentData: CardReviewData,
  rating: DifficultyRating,
): ReviewResult {
  let { easeFactor, interval, repetitions, state } = currentData;

  // Calcular novo Ease Factor
  const newEaseFactor = calculateEaseFactor(easeFactor, rating);

  // Determinar novo intervalo baseado na resposta
  if (rating < 3) {
    // Resposta incorreta (Again ou Hard)
    repetitions = 0;
    interval = 1;
    state = state === "new" ? "learning" : "relearning";
  } else {
    // Resposta correta (Good ou Easy)
    repetitions += 1;

    if (repetitions === 1) {
      interval = 1;
      state = "learning";
    } else if (repetitions === 2) {
      interval = 6;
      state = "review";
    } else {
      interval = Math.round(interval * newEaseFactor);
      state = "review";
    }

    // Ajuste adicional baseado no rating
    if (rating === 4) {
      // Easy: aumentar intervalo
      interval = Math.round(interval * 1.3);
    } else if (rating === 2) {
      // Hard (mas correto): reduzir intervalo
      interval = Math.max(1, Math.round(interval * 0.85));
    }
  }

  // Calcular data de vencimento
  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + interval);

  return {
    newEaseFactor,
    newInterval: interval,
    newRepetitions: repetitions,
    newState: state,
    dueDate,
  };
}

function calculateEaseFactor(
  currentEF: number,
  rating: DifficultyRating,
): number {
  // F√≥rmula SM-2
  const newEF = currentEF + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));

  // Garantir limites
  return Math.max(MIN_EASE_FACTOR, Math.min(MAX_EASE_FACTOR, newEF));
}

// lib/algorithm/scheduler.ts
export async function getDueCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 20,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .lte("due_date", new Date().toISOString())
    .order("due_date", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}

export async function getNewCards(
  supabase: SupabaseClient,
  userId: string,
  deckId?: string,
  limit: number = 10,
) {
  let query = supabase
    .from("card_states")
    .select(
      `
      *,
      card:cards (
        *,
        deck:decks (*)
      )
    `,
    )
    .eq("user_id", userId)
    .eq("state", "new")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (deckId) {
    query = query.eq("card.deck_id", deckId);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
}
```

### **Como evitar recalcular desnecessariamente:**

1. **Cache em mem√≥ria durante a sess√£o**: Manter estado em React durante sess√£o de estudo
2. **C√°lculo s√≥ no submit**: Calcular apenas quando usu√°rio avaliar o card
3. **√çndices otimizados**: √çndice composto em `(user_id, due_date)`
4. **Materializa√ß√£o de views**: Criar views materializadas para estat√≠sticas agregadas
5. **Debouncing**: Evitar m√∫ltiplos c√°lculos ao mesmo tempo

---

## 4. üì§ IMPORTA√á√ÉO VIA CSV

### **Parser de CSV com Suporte a Formata√ß√£o**

```typescript
// lib/parsers/csv-parser.ts
import { parse } from "csv-parse/sync";

export interface ParsedCard {
  front: string;
  back: string;
  frontHtml: string;
  backHtml: string;
}

export interface CSVParseResult {
  success: boolean;
  cards: ParsedCard[];
  errors: string[];
}

export async function parseFlashcardCSV(
  fileContent: string,
): Promise<CSVParseResult> {
  const errors: string[] = [];
  const cards: ParsedCard[] = [];

  try {
    // Parse CSV
    const records = parse(fileContent, {
      skip_empty_lines: true,
      relax_quotes: true,
      escape: "\\",
      columns: false,
    });

    // Validar e processar cada linha
    for (let i = 0; i < records.length; i++) {
      const row = records[i];

      if (row.length < 2) {
        errors.push(
          `Linha ${i + 1}: formato inv√°lido (esperado: frente,verso)`,
        );
        continue;
      }

      const front = row[0]?.trim();
      const back = row[1]?.trim();

      if (!front || !back) {
        errors.push(`Linha ${i + 1}: frente ou verso vazio`);
        continue;
      }

      // Converter marca√ß√µes para HTML
      const frontHtml = parseMarkdownToHtml(front);
      const backHtml = parseMarkdownToHtml(back);

      cards.push({
        front,
        back,
        frontHtml,
        backHtml,
      });
    }

    return {
      success: errors.length === 0,
      cards,
      errors,
    };
  } catch (error) {
    return {
      success: false,
      cards: [],
      errors: [`Erro ao processar CSV: ${error.message}`],
    };
  }
}

// lib/parsers/markdown-parser.ts
import DOMPurify from "isomorphic-dompurify";
import katex from "katex";

export function parseMarkdownToHtml(text: string): string {
  let html = text;

  // 1. Processar f√≥rmulas matem√°ticas ($...$)
  html = html.replace(/\$(.+?)\$/g, (match, formula) => {
    try {
      return katex.renderToString(formula, {
        throwOnError: false,
        displayMode: false,
      });
    } catch (error) {
      return `<span class="text-red-500">Erro: ${formula}</span>`;
    }
  });

  // 2. Processar negrito (**texto** ou __texto__)
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");

  // 3. Processar it√°lico (*texto* ou _texto_)
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");

  // 4. Processar subscrito (~texto~)
  html = html.replace(/~(.+?)~/g, "<sub>$1</sub>");

  // 5. Processar sobrescrito (^texto^)
  html = html.replace(/\^(.+?)\^/g, "<sup>$1</sup>");

  // 6. Processar c√≥digo inline (`c√≥digo`)
  html = html.replace(
    /`(.+?)`/g,
    '<code class="bg-gray-200 dark:bg-gray-800 px-1 rounded">$1</code>',
  );

  // 7. Processar quebras de linha
  html = html.replace(/\n/g, "<br>");

  // 8. Sanitizar contra XSS
  html = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ["strong", "em", "sub", "sup", "code", "br", "span", "div"],
    ALLOWED_ATTR: ["class", "style"],
  });

  return html;
}

// lib/parsers/sanitizer.ts
import DOMPurify from "isomorphic-dompurify";

export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "strong",
      "em",
      "u",
      "s",
      "sub",
      "sup",
      "code",
      "pre",
      "span",
      "div",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
    ],
    ALLOWED_ATTR: ["class", "style"],
  });
}
```

### **Server Action para Importa√ß√£o**

```typescript
// lib/actions/import-actions.ts
"use server";

import { createServerClient } from "@/lib/supabase/server";
import { parseFlashcardCSV } from "@/lib/parsers/csv-parser";
import { revalidatePath } from "next/cache";

export async function importCardsFromCSV(deckId: string, csvContent: string) {
  const supabase = await createServerClient();

  // Verificar autentica√ß√£o
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: "N√£o autenticado" };
  }

  // Verificar se o deck pertence ao usu√°rio
  const { data: deck, error: deckError } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", user.id)
    .single();

  if (deckError || !deck) {
    return { success: false, error: "Deck n√£o encontrado" };
  }

  // Parse do CSV
  const parseResult = await parseFlashcardCSV(csvContent);

  if (!parseResult.success || parseResult.cards.length === 0) {
    return {
      success: false,
      error: "Erro ao processar CSV",
      details: parseResult.errors,
    };
  }

  // Inserir cards em batch
  const cardsToInsert = parseResult.cards.map((card, index) => ({
    deck_id: deckId,
    front: card.front,
    back: card.back,
    front_html: card.frontHtml,
    back_html: card.backHtml,
    position: index,
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(cardsToInsert)
    .select();

  if (error) {
    return { success: false, error: error.message };
  }

  revalidatePath(`/decks/${deckId}`);

  return {
    success: true,
    imported: data.length,
    warnings: parseResult.errors,
  };
}
```

---

## 5. üîê ESTRAT√âGIA DE AUTENTICA√á√ÉO

### **Configura√ß√£o do Supabase**

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}

// lib/supabase/server.ts
import { createServerClient as createSSRClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createServerClient() {
  const cookieStore = await cookies();

  return createSSRClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: "", ...options });
        },
      },
    },
  );
}

// middleware.ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          request.cookies.set({ name, value: "", ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Rotas protegidas
  if (!user && request.nextUrl.pathname.startsWith("/decks")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Redirecionar se j√° logado
  if (
    user &&
    (request.nextUrl.pathname === "/login" ||
      request.nextUrl.pathname === "/signup")
  ) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return response;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

---

## 6.

```

```
